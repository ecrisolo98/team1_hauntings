<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Haunted Places Stress Radial Chart</title>
<style>
body {
  font: 12px sans-serif;
}

svg {
  margin: 0px auto;
  display: block;
}

path.arc {
  opacity: 0.9;
  transition: opacity 0.5s;
}

path.arc:hover {
  opacity: 0.7;
}

.axis line, .axis circle {
  stroke: #cccccc;
  stroke-width: 1px;
}

.axis circle {
  fill: none;
}

.r.axis text {
  text-anchor: end;
}

.tooltip {
  position: absolute;
  display: none;
  background: rgba(0, 0, 0, 0.6);
  border-radius: 3px;
  box-shadow: -3px 3px 15px #888;
  color: white;
  padding: 6px;
}
</style>
<script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
<script>
const width = 960,
  height = 500,
  chartRadius = height / 2 - 40;

let svg = d3.select('body').append('svg')
  .attr('width', width)
  .attr('height', height)
  .append('g')
    .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

let tooltip = d3.select('body').append('div')
  .attr('class', 'tooltip');

const PI = Math.PI,
  arcMinRadius = 10,
  arcPadding = 10,
  labelPadding = -5,
  numTicks = 10;

d3.json('../data/viz5data.json').then(data => {
  
  const color = d3.scaleSequential()
    .domain([d3.max(data, d => d.Overall_Stress_Rank), d3.min(data, d => d.Overall_Stress_Rank)])
    .interpolator(d3.interpolateCool);

  let scale = d3.scaleLinear()
    .domain([0, d3.max(data, d => parseInt(d.counts)) * 1.1])
    .range([0, 2 * PI]);

  let ticks = scale.ticks(numTicks).slice(0, -1);
  let keys = data.map((d, i) => d.state);

  const numArcs = keys.length;
  const arcWidth = (chartRadius - arcMinRadius - numArcs * arcPadding) / numArcs;

  let arc = d3.arc()
    .innerRadius((d, i) => getInnerRadius(i))
    .outerRadius((d, i) => getOuterRadius(i))
    .startAngle(0)
    .endAngle((d, i) => scale(d));

  let radialAxis = svg.append('g')
    .attr('class', 'r axis')
    .selectAll('g')
      .data(data)
      .enter().append('g');

  radialAxis.append('circle')
    .attr('r', (d, i) => getOuterRadius(i) + arcPadding);

  radialAxis.append('text')
    .attr('x', labelPadding)
    .attr('y', (d, i) => -getOuterRadius(i) + arcPadding)
    .text(d => d.state);

  let axialAxis = svg.append('g')
    .attr('class', 'a axis')
    .selectAll('g')
      .data(ticks)
      .enter().append('g')
        .attr('transform', d => 'rotate(' + (rad2deg(scale(d)) - 90) + ')');

  axialAxis.append('line')
    .attr('x2', chartRadius);

  axialAxis.append('text')
    .attr('x', chartRadius + 10)
    .style('text-anchor', d => (scale(d) >= PI && scale(d) < 2 * PI ? 'end' : null))
    .attr('transform', d => 'rotate(' + (90 - rad2deg(scale(d))) + ',' + (chartRadius + 10) + ',0)')
    .text(d => d);

  // Data arcs
  let arcs = svg.append('g')
    .attr('class', 'data')
    .selectAll('path')
      .data(data)
      .enter().append('path')
      .attr('class', 'arc')
      .style('fill', d => color(d.Overall_Stress_Rank));

  arcs.transition()
    .delay((d, i) => i * 200)
    .duration(1000)
    .attrTween('d', arcTween);

  arcs.on('mousemove', (event, d) => showTooltip(event, d))
    .on('mouseout', hideTooltip);

  // Show tooltip
  function showTooltip(event, d) {
    tooltip.style('left', (event.pageX + 10) + 'px')
      .style('top', (event.pageY - 25) + 'px')
      .style('display', 'inline-block')
      .html(d.counts);
  }

  function hideTooltip() {
    tooltip.style('display', 'none');
  }

  function rad2deg(angle) {
    return angle * 180 / PI;
  }

  function getInnerRadius(index) {
    return arcMinRadius + (numArcs - (index + 1)) * (arcWidth + arcPadding);
  }

  function getOuterRadius(index) {
    return getInnerRadius(index) + arcWidth;
  }

  // Legend
  let legendWidth = 300,
      legendHeight = 10;

  // Create a new group for the legend
  let legendSvg = d3.select('svg').append('g')
    .attr('transform', 'translate(' + (width / 2 - legendWidth / 2) + ',' + (height - 60) + ')');

  let defs = d3.select('svg').append("defs");

  let linearGradient = defs.append("linearGradient")
    .attr("id", "legend-gradient")
    .attr("x1", "0%")
    .attr("y1", "0%")
    .attr("x2", "100%")
    .attr("y2", "0%");

  linearGradient.selectAll("stop")
    .data([
      { offset: "0%", color: color(d3.max(data, d => d.Overall_Stress_Rank)) },
      { offset: "100%", color: color(d3.min(data, d => d.Overall_Stress_Rank)) }
    ])
    .enter().append("stop")
    .attr("offset", d => d.offset)
    .attr("stop-color", d => d.color);

  legendSvg.append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", legendWidth)
    .attr("height", legendHeight)
    .style("fill", "url(#legend-gradient)");

  legendSvg.append("text")
    .attr("x", 0)
    .attr("y", 25)
    .attr("text-anchor", "start")
    .style("fill", "#000")
    .text(d3.max(data, d => d.Overall_Stress_Rank));

  legendSvg.append("text")
    .attr("x", legendWidth)
    .attr("y", 25)
    .attr("text-anchor", "end")
    .style("fill", "#000")
    .text(d3.min(data, d => d.Overall_Stress_Rank));

  legendSvg.append("text")
    .attr("x", legendWidth / 2)
    .attr("y", 45)
    .attr("text-anchor", "middle")
    .style("fill", "#000")
    .text("Overall Stress Rank");
});
</script>
</body>
</html>
